# RFC-0000: Portable Countdown Format

*Author: Marco Quinten, FiveSheep OÜ*  
*Status: Informational*  
*Date: August 27, 2025*  

---

## Abstract

This RFC introduces the **Portable Countdown Format**, a JSON-based open specification for sharing countdown events across applications.

The format was first implemented in the app **Cursed Countdowns** ([App Store link](https://apps.apple.com/app/id6749811515)), which uses it to let users create, export, and share countdowns in a structured, portable way.  

The goal of this document is not to define the technical details of the format (see [SPEC-V1.md](../SPEC-V1.md) for the normative specification), but to describe the **motivation, design philosophy, and reasoning** behind the initial version of the format.

---

## Motivation

Countdowns are universally understood, but traditionally locked into individual apps or services. Sharing them usually means sending screenshots or plaintext descriptions like *“Apophis passes in 1349 days”*.  

This creates three problems:

1. **Lack of portability**  
   A countdown created in one app cannot easily be imported into another.  

2. **Loss of structure**  
   Important metadata such as the target date, title, or description is lost when using unstructured text or images.  

3. **Limited localization**  
   Countdowns shared in one language are often inaccessible or awkward in another.  

The Portable Countdown format addresses these by defining a **neutral, app-independent format** that can encode essential countdown data (title, summary, details, target date, and localization), while still leaving room for **vendor-specific extensions**.

---

## Inspirations and Design Choices

The format draws inspiration from existing open standards such as:

- **iCalendar (RFC 5545)** → for structured time and event representation  
- **JSON Schema** → for validation and portability  
- **Reverse-DNS namespacing** → for vendor extensions

Key decisions for Version 1:

1. **JSON Container**  
   - Chosen for simplicity and universal support.  
   - Avoided binary formats to maximize accessibility and debugging ease.  
   - File size is not a primary concern, as countdowns are typically small and text-based.

2. **Stable Identifiers**  
   - `id` is a UUID to guarantee uniqueness across exports.  
   - This enables deduplication and reference integrity.  

3. **Timestamps as ISO 8601**  
   - Human-readable, widely supported, timezone-safe.  
   - Easier for developers than raw epoch timestamps.  

4. **Localization as First-Class**  
   - Separate `data` (default) and `localizedData` (per-locale).  
   - Keys MUST be BCP-47 language tags for compatibility.  
   - Ensures a countdown can be shared globally without modification.  

5. **Vendor Extensions**  
   - Namespaced (`co.fivesheep.CursedCountdowns`) to prevent collisions.  
   - Future-proof: allows apps to store hints (e.g., preferred theme) without polluting the core schema.  

6. **Minimalism**  
   - Intentionally small scope: title, summary, details, timestamps.  
   - Leaves appearance, themes, and rendering choices to vendors.  

---

## Use in Cursed Countdowns

The first production implementation is in **Cursed Countdowns** ([App Store](https://apps.apple.com/app/id6749811515)), an iOS app for discovering, creating, and sharing countdowns.  

Within the app, Portable Countdown files serve three purposes:

1. **Export/Import**  
   Users can export a `.cntdwn` file and share it with friends, who can then import it.  

2. **Viral Sharing**  
   By standardizing metadata, exported countdowns can circulate in communities without losing structure.  

3. **Future-Proofing**  
   Even though Cursed Countdowns is currently the only app that supports the format, the open spec ensures others can adopt it without friction.  

---

## Why Not Just Screenshots?

While screenshots are visually appealing, they:  
- Cannot be localized  
- Lose accuracy (e.g., when cropped or stylized)  
- Are not machine-readable  

Portable Countdown files complement screenshots: the app **still generates images for social media**, but backs them with a structured export that preserves the underlying data.

One could make an argument for _embedding portable countdown files into images_, and this is something we're planning to explore in the future. This idea has been widely used for LLM character cards, and has proven to work quite well. It comes with a lot more complexity though, and thus isn't a priority for the initial implementation.

---

## Future Directions

- **Interoperability**: Encourage adoption by other apps in the productivity, events, or entertainment space.  
- **Dynamic fields**: Future versions may support recurring countdowns, fuzzy precision (“sometime in Q4”), or API-based live events. We want to be security-conscious though, and minimize potential attack vectors.  
- **Community catalogs**: Shared repositories of countdowns could use this format as their interchange layer.  

---

## Conclusion

The **Portable Countdown Format** is designed to make countdowns *portable, localized, and future-proof*.  
It balances **simplicity** (easy to implement) with **extensibility** (via vendor extensions).  

Cursed Countdowns is the first implementation, but the goal is a wider ecosystem where countdowns can move freely between apps, services, and platforms.  

For now, users can try it directly in [Cursed Countdowns on iOS](https://apps.apple.com/app/id6749811515).

---

*End of RFC-0000*